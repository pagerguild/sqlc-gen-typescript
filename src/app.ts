import { readFileSync, writeFileSync, STDIO } from "javy/fs";
import {
  EmitHint,
  NewLineKind,
  ScriptKind,
  ScriptTarget,
  SyntaxKind,
  Node,
  createPrinter,
  createSourceFile,
  factory,
} from "typescript";

import { GenerateRequest, GenerateResponse, File } from "./gen/plugin/codegen_pb";

import { argName, colName } from "./drivers/utils";
import { assertUniqueNames } from "./validate";
import * as postgres from "./drivers/postgres";

// Read input from stdin
const input = readInput();
// Call the function with the input
const result = codegen(input);
// Write the result to stdout
writeOutput(result);

function codegen(input: GenerateRequest): GenerateResponse {
  let files = [];

  const querymap = new Map<string, typeof input.queries>();

  for (const query of input.queries) {
    if (!querymap.has(query.filename)) {
      querymap.set(query.filename, []);
    }
    const qs = querymap.get(query.filename);
    qs?.push(query);
  }

  for (const [filename, queries] of querymap.entries()) {
    const nodes: Node[] = [...postgres.preamble()];

    for (const query of queries) {
      const lowerName = query.name[0].toLowerCase() + query.name.slice(1);

      let argIface = undefined;
      let returnIface = undefined;

      if (query.params.length > 0) {
        argIface = `${query.name}Args`;
        const names = query.params.map((param, i) => argName(i, param.column));
        assertUniqueNames({
          kind: "argument",
          queryName: query.name,
          fileName: filename,
          names,
        });

        nodes.push(
          factory.createInterfaceDeclaration(
            [factory.createToken(SyntaxKind.ExportKeyword)],
            factory.createIdentifier(argIface),
            undefined,
            undefined,
            query.params.map((param, i) =>
              factory.createPropertySignature(
                undefined,
                factory.createIdentifier(argName(i, param.column)),
                undefined,
                postgres.columnType(param.column),
              ),
            ),
          ),
        );
      }

      if (query.columns.length > 0) {
        returnIface = `${query.name}Row`;
        const names = query.columns.map((column, i) => colName(i, column));
        assertUniqueNames({
          kind: "column",
          queryName: query.name,
          fileName: filename,
          names,
        });

        nodes.push(
          factory.createInterfaceDeclaration(
            [factory.createToken(SyntaxKind.ExportKeyword)],
            factory.createIdentifier(returnIface),
            undefined,
            undefined,
            query.columns.map((column, i) =>
              factory.createPropertySignature(
                undefined,
                factory.createIdentifier(colName(i, column)),
                undefined,
                postgres.columnType(column),
              ),
            ),
          ),
        );
      }

      switch (query.cmd) {
        case ":exec": {
          nodes.push(postgres.execDecl(lowerName, query.text, argIface, query.params));
          break;
        }
        case ":execlastid": {
          nodes.push(postgres.execlastidDecl(lowerName, query.text, argIface, query.params));
          break;
        }
        case ":one": {
          nodes.push(
            postgres.oneDecl(
              lowerName,
              query.text,
              argIface,
              returnIface ?? "void",
              query.params,
              query.columns,
            ),
          );
          break;
        }
        case ":many": {
          nodes.push(
            postgres.manyDecl(
              lowerName,
              query.text,
              argIface,
              returnIface ?? "void",
              query.params,
              query.columns,
            ),
          );
          break;
        }
      }
    }

    files.push(
      new File({
        name: `${filename.replace(".", "_")}.ts`,
        contents: new TextEncoder().encode(printNode(nodes)),
      }),
    );
  }

  return new GenerateResponse({
    files: files,
  });
}

// Read input from stdin
function readInput(): GenerateRequest {
  const buffer = readFileSync(STDIO.Stdin);
  return GenerateRequest.fromBinary(buffer);
}

function printNode(nodes: Node[]): string {
  const resultFile = createSourceFile(
    "file.ts",
    "",
    ScriptTarget.Latest,
    /*setParentNodes*/ false,
    ScriptKind.TS,
  );
  const printer = createPrinter({ newLine: NewLineKind.LineFeed });
  let output = "// Code generated by sqlc. DO NOT EDIT.\n\n";
  for (let node of nodes) {
    output += printer.printNode(EmitHint.Unspecified, node, resultFile);
    output += "\n\n";
  }
  return output;
}

// Write output to stdout
function writeOutput(output: GenerateResponse) {
  const encodedOutput = output.toBinary();
  const buffer = new Uint8Array(encodedOutput);
  writeFileSync(STDIO.Stdout, buffer);
}
